@page "/primarydisplay"
@using BanchoSharp.Interfaces
@using BanchoSharp.Multiplayer
@using Brigitta.Extensions
@using BrigittaBlazor.Derivatives

@attribute [Authorize]

@inject IBanchoClient Client
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@inject ILogger<PrimaryDisplay> Logger
@inject IDialogService DialogService

@functions {

    private async Task ScrollToBottom(string divId)
    {
        if (_autoScroll)
        {
            try
            {
                await JS.InvokeVoidAsync("scrollToBottom", divId);
            }
            catch (Exception)
            {
    //  
            }
        }
    }

}

<MudGrid Spacing="2" Style="margin-top: -50px">
    <MudItem xs="12">
        <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">This view is incomplete. Expect bugs.</MudAlert>
    </MudItem>
    <MudItem xs="12" sm="8" lg="5">
        <MudPaper>
            <div id="@_consoleDivId" Class="overflow-scroll" style="height: 400px;">
                @if (_currentlySelectedChannel != null)
                {
                    foreach (var message in ((IChatChannel)_currentlySelectedChannel).MessageHistory!)
                    {
                        if (message is not IPrivateIrcMessage priv)
                        {
                            continue;
                        }

                        @if (_utcTime)
                        {
                            <MudText Style="word-wrap: anywhere" Inline="true">@(priv.ToUTCTimeString() + " ")</MudText>
                        }
                        else
                        {
                            <MudText Style="word-wrap: anywhere" Inline="true">@(priv.ToTimeString() + " ")</MudText>
                        }

                        <MudText Inline="true"> </MudText>

                        <MudLink Underline="Underline.Hover" Color="@GetUsernameColor(priv.Sender)"
                                 Href="@GetUsernameLink(priv.Sender)" Target="blank">
                            <MudText Style="word-wrap: anywhere" Inline="true" Color="@GetUsernameColor(priv.Sender)">@priv.Sender</MudText>
                        </MudLink>
                        <MudText Style="word-wrap: anywhere" Inline="true">@priv.Content</MudText>
                        <MudText/>
                    }
                }
            </div>
            <MudPaper>
                <MudTextField @ref="RefEntryField" @bind-Value="_textChatValue" Label="Send a message" Immediate="true"
                              Variant="Variant.Outlined" T="string"
                              Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Send" AdornmentColor="Color.Success"
                              OnKeyDown="OnTextChatSend" OnAdornmentClick="ForceChatSend"/>
            </MudPaper>
        </MudPaper>
    </MudItem>
    <MudItem xs="12" sm="4" lg="3">
        <MudPaper>
            <MudList Clickable="true" @bind-SelectedValue="_currentlySelectedChannel"
                     Style="height: 400px">
                @foreach (var channel in Client.Channels)
                {
                    <MudListItem Icon="@Icons.Material.Outlined.Chat"
                                 Value="@channel" OnClick="() => ScrollConsoleToBottom(5)">
                        @channel.ChannelName
                    </MudListItem>
                }
            </MudList>
            <MudStack Row="true">
                <MudTooltip Text="Add channel">
                    <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Large" Color="Color.Success"
                                   OnClick="@OpenAddChannelDialog"/>
                </MudTooltip>

                <MudTooltip Text="@_autoScrollToolTip">
                    <MudToggleIconButton @bind-Toggled="_autoScroll" Icon="@Icons.Material.Filled.ArrowDownward"
                                         Size="Size.Large" ToggledSize="Size.Large"
                                         ToggledColor="Color.Success" ToggledIcon="@Icons.Material.Filled.ArrowCircleDown"/>
                </MudTooltip>

                <MudSwitch @bind-Checked="_utcTime" Color="Color.Info" Label="UTC"/>
            </MudStack>
        </MudPaper>
    </MudItem>

    @if (_currentlySelectedChannel is IMultiplayerLobby mp)
    {
        // We are inside of a multiplayer lobby channel.
        <MudItem xs="12" lg="4">
            <MudGrid Spacing="2">
                <MudItem xs="12" sm="6" lg="12">
                    <MudPaper>
                        <MudGrid Spacing="2">
                            <MudItem>
                                <MudIcon Icon="@Icons.Material.Filled.DriveFileRenameOutline"/>
                                <MudLink Href="@mp.HistoryUrl" Underline="Underline.Hover" Color="Color.Primary" Target="blank">
                                    <MudText Inline="true">
                                        <b>@mp.Name</b>
                                    </MudText>
                                </MudLink>
                            </MudItem>
                            <MudItem>
                                <MudGrid Spacing="1">
                                    <MudItem>
                                        <MudIcon Icon="@Icons.Material.Filled.Numbers"/>
                                        <MudText Inline="true">
                                            <b>Size:</b> @mp.Size
                                        </MudText>
                                    </MudItem>
                                    <MudItem>
                                        <MudIcon Icon="@Icons.Material.Filled.PeopleAlt"/>
                                        <MudText Inline="true">
                                            <b>Players:</b> @mp.PlayerCount
                                        </MudText>
                                    </MudItem>
                                    <MudItem>
                                        <MudIcon Icon="@Icons.Material.Filled.HourglassBottom"/>
                                        <MudText Inline="true">@(mp.LobbyTimerInProgress ? mp.LobbyTimerRemaining.ToFormattedDuration() : "No timer active")</MudText>
                                    </MudItem>
                                    <MudItem>
                                        @*Format*@
                                        <MudIcon Icon="@Icons.Material.Filled.AssignmentTurnedIn"/>
                                        <MudText Inline="true">
                                            <b>Format:</b> @mp.Format
                                        </MudText>
                                    </MudItem>
                                    <MudItem>
                                        @*Win condition*@
                                        <MudIcon Icon="@Icons.Material.Filled.Flag"/>
                                        <MudText Inline="true">
                                            <b>WC:</b> @mp.WinCondition
                                        </MudText>
                                    </MudItem>
                                    <MudItem>
                                        @*Gamemode*@
                                        <MudIcon Icon="@Icons.Material.Filled.VideogameAsset"/>
                                        <MudText Inline="true">
                                            <b>Mode:</b> @mp.GameMode
                                        </MudText>
                                    </MudItem>
                                </MudGrid>

                            </MudItem>

                            <MudItem>
                                <MudStack Row="true" @bind-SelectedValue="@_currentlySelectedPlayer"
                                          Class="overflow-scroll" Style="max-height: 250px;">
                                    @foreach (var player in mp.Players)
                                    {
                                        var statusDisplay = new PlayerStatusDisplay(player);
                                        <MudListItem Value="@player" Icon="@(player.IsReady ? Icons.Material.Filled.Check : Icons.Material.Filled.Error)"
                                                     IconColor="@(player.IsReady ? Color.Success : Color.Warning)">
                                            <MudLink Href="@statusDisplay.Url" Target="blank">
                                                <MudImage src="@($"http://s.ppy.sh/a/{player.Id ?? 1}")" Width="48" Height="48" Elevation="25" Class="rounded-sm"/>
                                                <MudText Color="@statusDisplay.PlayerTeamColor">@player.Name</MudText>
                                            </MudLink>
                                        </MudListItem>
                                    }
                                </MudStack>
                            </MudItem>
                        </MudGrid>
                    </MudPaper>
                </MudItem>
                <MudItem xs="12" sm="6" lg="12">
                    <MudPaper>
                        <MudNumericField @bind-Value="@_mpTimerValue" Label="Timer Seconds" Variant="Variant.Outlined" Min="0" Max="600" Step="30"/>

                        <MudGrid Spacing="20">
                            <MudTooltip Text="Start a timer">
                                <MudIconButton Color="Color.Inherit" OnClick="@(() => mp.SetTimerAsync(_mpTimerValue))"
                                               Icon="@Icons.Material.Filled.HourglassBottom" Size="Size.Large"/>
                            </MudTooltip>

                            @*Refresh !mp settings*@
                            <MudTooltip Text="!mp settings">
                                <MudIconButton Icon="@Icons.Material.Filled.SettingsBackupRestore"
                                               OnClick="@(async () => await mp.RefreshSettingsAsync())" Size="Size.Large"/>
                            </MudTooltip>

                            <MudTooltip Text="Locks / unlocks the lobby. If the lobby is locked, players cannot change slots at will.">
                                @*Abort timer*@
                                @if (mp.IsLocked)
                                {
                                    <MudIconButton Color="Color.Inherit" Icon="@Icons.Material.Filled.LockOpen"
                                                   OnClick="@(async () => await mp.UnlockAsync())" Size="Size.Large"/>
                                }
                                else
                                {
                                    <MudIconButton Color="Color.Warning" Icon="@Icons.Material.Filled.LockPerson"
                                                   OnClick="@(async () => await mp.LockAsync())" Size="Size.Large"/>
                                }
                            </MudTooltip>

                            <MudTooltip Text="Abort the current timer, if there is one">
                                @*Abort timer*@
                                <MudIconButton Color="Color.Error" Icon="@Icons.Material.Filled.HourglassDisabled"
                                               OnClick="@(async () => await mp.AbortTimerAsync())" Size="Size.Large"/>
                            </MudTooltip>

                            <MudTooltip Text="Abort the match">
                                @*Abort lobby*@
                                <MudIconButton Color="Color.Error"
                                               OnClick="@(async () => await mp.AbortAsync())" Icon="@Icons.Material.Filled.Dangerous" Size="Size.Large"/>
                            </MudTooltip>
                        </MudGrid>
                    </MudPaper>
                </MudItem>
            </MudGrid>
        </MudItem>
    }
</MudGrid>

@* Add channel dialog *@
<MudDialog @bind-IsVisible="_addChannelDialogIsVisible" Options="_dialogOptions">
    <DialogContent>
        <p>Add a channel</p>
        <MudTextField Label="Channel" T="string" @bind-Value="_addChannelDialogValue"
                      Validation="@(new Func<string, IEnumerable<string>>(AddChannelValidation))"/>
    </DialogContent>
    <DialogActions>
        <MudButton Color="Color.Error" OnClick="CloseAddChannelDialog">Cancel</MudButton>
        <MudButton Color="Color.Success" OnClick="AddChannelAsync">Add</MudButton>
    </DialogActions>
</MudDialog>


@code {
    // Dialogs
    private readonly DialogOptions _dialogOptions = new()
    {
        CloseOnEscapeKey = true
    };
    private bool _addChannelDialogIsVisible;

    private void OpenAddChannelDialog()
    {
        _addChannelDialogIsVisible = true;
        _addChannelDialogValue = "";
    }

    private void CloseAddChannelDialog() => _addChannelDialogIsVisible = false;
    private string _addChannelDialogValue;
    private string? _textChatValue;
    private object? _currentlySelectedChannel;
    private object? _currentlySelectedPlayer;
    private IChatChannel? _castedCurrentlySelectedChannel => (IChatChannel?)_currentlySelectedChannel;
    private IMultiplayerLobby? _currentlySelectedLobby => _currentlySelectedChannel is IMultiplayerLobby mp ? mp : null;
    private bool _autoScroll = true;
    private bool _utcTime;
    private string _autoScrollToolTip => _autoScroll ? "AutoScroll (currently enabled)" : "AutoScroll (currently disabled)";
    private MudTextField<string> RefEntryField;
    private string _consoleDivId => "console";
    private int _mpTimerValue = 120;

    protected override void OnInitialized()
    {
        Client.OnMessageReceived += async m =>
        {
            if (m is IPrivateIrcMessage priv)
            {
                Logger.LogDebug($"Private message received: {priv}");

                if (_castedCurrentlySelectedChannel == null)
                {
                    return;
                }

                if ((priv.IsDirect && priv.Sender.Equals(_castedCurrentlySelectedChannel.ChannelName)) ||
                    (!priv.IsDirect && priv.Recipient.Equals(_castedCurrentlySelectedChannel.ChannelName)))
                {
                    await InvokeAsync(StateHasChanged);
                }
            }
        };
        Client.OnPrivateMessageSent += async _ => await ScrollConsoleToBottom();
        Client.OnPrivateMessageReceived += async _ => await ScrollConsoleToBottom();

        Client.OnChannelJoined += async channel =>
        {
            Snackbar.Add($"Joined channel {channel}", Severity.Success);
    // _currentlySelectedChannel = channel;

            await InvokeAsync(StateHasChanged);
        };

        Client.OnUserQueried += async user =>
        {
            Snackbar.Add($"Opened conversation with {user}", Severity.Success);
            await InvokeAsync(StateHasChanged);
        };

        Client.OnChannelParted += async channel =>
        {
            if (_currentlySelectedChannel.Equals(channel))
            {
                _currentlySelectedChannel = Client.Channels.LastOrDefault();
            }

            await InvokeAsync(StateHasChanged);
        };

        Client.OnChannelJoinFailure += async channel =>
        {
            Snackbar.Add($"Failed to join channel {channel}", Severity.Error);
            await InvokeAsync(StateHasChanged);

            if (_currentlySelectedChannel.Equals(channel))
            {
                _currentlySelectedChannel = Client.Channels.LastOrDefault();
            }
        };

        Client.BanchoBotEvents.OnTournamentLobbyCreated += lobby =>
        {
            Snackbar.Add($"Created the tournament match: {lobby.Name}", Severity.Info);

    // Register lobby events
            lobby.OnMatchStarted += () => Snackbar.Add($"Match started: {lobby.Name}", Severity.Info);
            lobby.OnMatchFinished += () => Snackbar.Add($"Match finished: {lobby.Name}", Severity.Info);
            lobby.OnMatchAborted += () => Snackbar.Add($"Match aborted: {lobby.Name}", Severity.Warning);
            lobby.OnClosed += () => Snackbar.Add($"Lobby closed: {lobby.Name}", Severity.Info);
            lobby.OnStateChanged += async () =>
            {
                await InvokeAsync(StateHasChanged);

                if (lobby.LobbyTimerInProgress)
                {
                    await Task.Run(async () =>
                    {
                        while (lobby.LobbyTimerInProgress && !lobby.IsClosed)
                        {
                            await Task.Delay(1000);
                            await InvokeAsync(StateHasChanged);
                        }
                    });
                }
            };
        };

        Task.Run(async () => await JoinDefaultChannels());

        _currentlySelectedChannel = Client.GetChannel("BanchoBot") ?? Client.Channels.FirstOrDefault();
    }

    private async Task JoinDefaultChannels()
    {
        await Client.JoinChannelAsync("#english");
        await Client.JoinChannelAsync("#osu");
        await Client.QueryUserAsync("BanchoBot");
        Client.Channels.Add(new MultiplayerLobby(Client, 12345, "OWC: (United States) Vs. (Germany)"));
    }

    private async Task ForceChatSend() => await OnTextChatSend(new KeyboardEventArgs
    {
        Key = "Enter"
    });

    private async Task OnTextChatSend(KeyboardEventArgs args)
    {
        if (args.Key is "Enter" or "NumppadEnter")
        {
            if (string.IsNullOrWhiteSpace(_textChatValue))
            {
                return;
            }

            var customCommandHandler = new CustomCommandHandler(_textChatValue);

            if (customCommandHandler is { Command: {}, IsBanchoCommand: true })
            {
    // Deploy directly to the server
                await Client.SendAsync(_textChatValue[1..]); // Remove leading slash
                
                // We've now handled the command, clear the chat field and return
                await ClearChatEntryField();
                return;
            }
            
            if (customCommandHandler is { Command: {}, IsBanchoCommand: false})
            {
    // Process custom command
                var command = customCommandHandler.CustomCommand;
                if (command != null)
                {
                    switch (command.Value.Command.ToLower())
                    {
                        case "clear":
                            await command.Value.Execute(new Func<IChatChannel?, Task>(channel =>
                            {
                                if (channel == null)
                                {
                                    return Task.CompletedTask;
                                }

                                channel.MessageHistory!.Clear();
                                return Task.CompletedTask;
                            }), _castedCurrentlySelectedChannel);
                            break;
                        case "chat":
                            if(!customCommandHandler.Parameters?.Any() ?? true)
                            {
                                break;
                            }
                            
                            string? recipient = customCommandHandler.Parameters?[0];
                            string message = string.Join(" ", customCommandHandler.Parameters?[1..] ?? Array.Empty<string>()).Trim();

                            if (recipient == null)
                            {
                                break;
                            }

                            await command.Value.Execute(new Func<string, string?, Task>(async (r, m) =>
                            {
                                if (r.StartsWith("#"))
                                {
    // Recipient is a channel
                                    await Client.JoinChannelAsync(r);
                                }
                                else
                                {
    // Recipient is a Bancho user
                                    await Client.QueryUserAsync(r);
                                }

    // Message exists? Message the channel or user
                                if (!string.IsNullOrWhiteSpace(m))
                                {
                                    await Client.SendPrivateMessageAsync(r, m);
                                }
                            }), recipient, message);
                            break;
                    }
                    
                    // Finally, clear the chat channel and return since we've handled the command.
                    await ClearChatEntryField();
                    return;
                }
            }

            // It's okay to handle slash commands without a selected
            // channel in some cases, but never for regular messages
            if (_currentlySelectedChannel == null)
            {
                return;
            }
            
            await Client.SendPrivateMessageAsync(((IChatChannel)_currentlySelectedChannel).ChannelName, _textChatValue);
            Logger.LogDebug($"Message sent: '{_textChatValue}' to {_currentlySelectedChannel}");

            await ClearChatEntryField();
        }
    }

    private async Task ClearChatEntryField()
    {
        RefEntryField.TextUpdateSuppression = false;
        _textChatValue = string.Empty;
        
        await InvokeAsync(StateHasChanged);
        await Task.Run(async () =>
        {
            await Task.Delay(150);
            RefEntryField.TextUpdateSuppression = true;
        });
    }

    private IEnumerable<string> AddChannelValidation(string channel)
    {
        if (string.IsNullOrWhiteSpace(channel))
        {
            yield return "Channel name must not be empty.";
        }
    }

    private async Task ScrollConsoleToBottom(int? delaySeconds = 0)
    {
        if (delaySeconds.HasValue)
        {
            await Task.Delay(delaySeconds.Value);
        }

        await ScrollToBottom(_consoleDivId);
    }

    private async Task AddChannelAsync()
    {
        await Client.JoinChannelAsync(_addChannelDialogValue);
        CloseAddChannelDialog();
    }

    private string GetUsernameLink(string username) => $"https://osu.ppy.sh/u/{username}";

    private Color GetUsernameColor(string username)
    {
        string loggedInUsername = Client.ClientConfig.Credentials.Username;
        switch (username)
        {
            case "BanchoBot":
                return Color.Error;
            default:
            {
                if (username == loggedInUsername)
                {
                    return Color.Primary;
                }
                break;
            }
        }
        return Color.Success;
    }

    public class PlayerStatusDisplay
    {
        private readonly IMultiplayerPlayer _player;
        public PlayerStatusDisplay(IMultiplayerPlayer player) { _player = player; }
        public Color StatusColor => GetStatusColor();
        public Color PlayerTeamColor => GetTeamColor();
        public string StatusIcon => GetStatusIcon();
        public string Url => GetPlayerUrl();

        private Color GetStatusColor()
        {
            if (_player.Lobby.Host?.Equals(_player) ?? false)
            {
                return Color.Primary;
            }
            if (!_player.IsReady)
            {
                return Color.Error;
            }

            return Color.Success;
        }

        private string GetStatusIcon()
        {
            if (_player.Lobby.Host?.Equals(_player) ?? false)
            {
    // Host == player, give crown
                return Icons.Material.Filled.Diamond;
            }
            if (!_player.IsReady)
            {
                return Icons.Material.Filled.Error;
            }

            return Icons.Material.Filled.Check;
        }

        private Color GetTeamColor() => _player.Team switch
        {
            TeamColor.None => Color.Inherit,
            TeamColor.Blue => Color.Info,
            TeamColor.Red => Color.Error
            };

        private string GetPlayerUrl()
        {
            if (_player.Id.HasValue)
            {
                return $"https://osu.ppy.sh/u/{_player.Id}";
            }

            return $"https://osu.ppy.sh/u/{_player.Name}";
        }
    }

}

